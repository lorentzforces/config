#!/usr/bin/env python3

import argparse
import os
import sys

DEFAULT_ENV_VAR = "TEST_PATH"
PATH_ENTRY_SEPARATOR = ":"

COMMAND_DESCRIPTION = (
"Parses a PATH string and inserts a new entry, but will not add an entry "
"more than once. The output is sent to stdout.\n"
"\n"
"If the provided new PATH entry is not a valid directory, this script will exit with an error.")

if __name__ == "__main__":
    arg_parser = argparse.ArgumentParser(
            formatter_class = argparse.RawDescriptionHelpFormatter,
            description = COMMAND_DESCRIPTION
    )

    # TODO: support adding multiple entries at once
    arg_parser.add_argument(
            dest = "new_entry",
            metavar = "PATH_ENTRY_STRING"
    )
    arg_parser.add_argument(
            "--first",
            dest = "ensure_first",
            action = "store_true",
            help = "ensure the entry is first in the path"
    )
    arg_parser.add_argument(
            "--allow-invalid-dir",
            dest = "allow_invalid_dir",
            action = "store_true",
            help = "set this option to allow adding a non-existant directory path as an entry"
    )
    arg_parser.add_argument(
            "--env",
            dest = "env_var",
            action = "store",
            default = DEFAULT_ENV_VAR,
            help = f"the environment variable to modify, defaults to {DEFAULT_ENV_VAR}"
    )

    args = arg_parser.parse_args()

    new_entry_system_path = os.path.realpath(args.new_entry)
    if not os.path.isdir(new_entry_system_path) and not args.allow_invalid_dir:
        raise SystemExit("ERROR: Provided path entry is not a directory")

    current_value = os.getenv(args.env_var)
    current_value = "" if current_value == None else current_value

    entries = current_value.split(PATH_ENTRY_SEPARATOR)

    incoming_entry_index = -1
    for i, entry in enumerate(entries):
        if entry == args.new_entry:
            incoming_entry_index = i
            break
    entry_exists = incoming_entry_index != -1

    should_append = args.ensure_first or not entry_exists

    if should_append:
        if args.ensure_first and entry_exists:
            entries.pop(incoming_entry_index)

        entries.insert(0, args.new_entry)

    print(":".join(entries))
