#!/usr/bin/env bash
set -u
IFS=$'\n\t'

# Figures out what package managers live on the system, then executes their "get upgradable
# packages" flow in parallel.

# file path to export output to instead of printing to stdout
UPDATE_LIST_OUTPUT_FILE=${UPDATE_LIST_OUTPUT_FILE:-}

main() {
	local -a require_sudo=()
	local -a check_commands=()
	get_check_command_list check_commands require_sudo

	# All of homebrew basically assumes that you will only ever use it as a single user on the
	# system, which is hard to square with some system package managers which require running as
	# root to update package metadata caches. The solution we use here is to require the overall
	# script to be run as non-root, and then "cache" a sudo invocation so that subsequent sudo
	# invocations will succeed non-interactively.
	if (( EUID == 0)); then
		>&2 echo "This script cannot be run overall as root, try again as a non-root user"
		exit 1
	fi

	if (( ${#require_sudo[@]} > 0 )); then
		>&2 printf "Root privileges required for: %s\n" "${require_sudo[*]}"
		>&2 echo "The script will now prompt you to authenticate using sudo"
		>&2 sudo echo "Successfully elevated with sudo" || exit 1
	fi

	output=$(parallel ::: "${check_commands[@]}")
	output+=$'\n\n\n'
	output+="This information generated at: $(date)"

	if [[ -n "$UPDATE_LIST_OUTPUT_FILE" ]]; then
		echo "$output" > "$UPDATE_LIST_OUTPUT_FILE"
		>&2 echo "Updatable packages output exported to: $UPDATE_LIST_OUTPUT_FILE"
	else
		echo "$output"
	fi
}

# arg 1: array name to populate with check commands
# arg 2: array name to populate with commands which require root access
get_check_command_list() {
	declare -n output_commands=$1
	declare -n output_require_sudo=$2

	if type -t apt-get > /dev/null ; then
		output_require_sudo+=("apt-get")
		output_commands+=('get_apt_updates')
	fi
	if type -t dnf > /dev/null ; then
		output_commands+=('get_dnf_updates')
	fi
	if type -t brew > /dev/null ; then
		output_commands+=('get_brew_updates')
	fi
	if type -t flatpak > /dev/null ; then
		output_commands+=('get_flatpak_updates')
	fi
	if type -t zypper > /dev/null ; then
		output_require_sudo+=("zypper")
		output_commands+=('get_zypper_updates')
		# output_commands+=('get_zypper_updates_test')
	fi
}

# NOTE: any functions which will be invoked within a parallel process must be exported with -f

get_apt_updates() {
	sudo apt-get update > /dev/null
	section_header "APT PACKAGES"
	apt list --upgradable
	echo ""
}
export -f get_apt_updates

get_dnf_updates() {
	dnf check-update --refresh > /dev/null
	section_header "APT PACKAGES"
	dnf list --updates
	echo ""
}
export -f get_dnf_updates

get_brew_updates() {
	# brew is VERY spammy to stderr
	section_header "HOMEBREW PACKAGES"
	brew outdated --verbose
	echo ""
	echo "Homebrew reminder:"
	echo "  To update homebrew itself, run \"homebrew update\""
	echo "  To update homebrew-managed packages, run \"homebrew upgrade\""
	echo ""
}
export -f get_brew_updates

get_flatpak_updates() {
	section_header "FLATPAK PACKAGES"
	{ flatpak remote-ls --updates --columns=name,version,download-size || return 1 ; } \
		| column --table --separator $'\t' --output-width 100
	echo ""
}
export -f get_flatpak_updates

get_zypper_updates() {
	section_header "ZYPPER PACKAGES"
	sudo zypper refresh > /dev/null
	# TODO: consider filtering & re-formatting the output of zypper list-updates:
	#   - remove header lines and progress updates
	#   - do not print arch
	#   - scrunch versions to make them take up less space
	#   - reorder everything to make it more scannable
	#   - pull out some notable packages of interest (like kernel, tumbleweed release, nvidia
	#     drivers, etc) to display separately
	zypper list-updates
	echo ""
}
export -f get_zypper_updates

get_zypper_updates_test() {
	section_header "ZYPPER PACKAGES (MOCKED)"
	sudo echo "This is mocked output from zypper. Pretend it's really long."
	echo ""
}
export -f get_zypper_updates_test

# arg 1: name of section to be displayed
section_header() {
	local section_header=$1
	echo -e "\nยง $section_header\n"
}
export -f section_header

main
