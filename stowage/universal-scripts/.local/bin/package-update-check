#!/usr/bin/env bash
set -u
IFS=$'\n\t'

# Figures out what package managers live on the system, then executes their "get upgradable
# packages" flow in parallel.

# file path to export output to instead of printing to stdout
UPDATE_LIST_OUTPUT_FILE=${UPDATE_LIST_OUTPUT_FILE:-}

BOLD=${ tput bold; }

main() {
	local -a package_managers=()
	local -a require_sudo=()
	local -a check_commands=()
	get_check_command_list "package_managers" "check_commands" "require_sudo"

	# All of homebrew basically assumes that you will only ever use it as a single user on the
	# system, which is hard to square with some system package managers which require running as
	# root to update package metadata caches. The solution we use here is to require the overall
	# script to be run as non-root, and then "cache" a sudo invocation so that subsequent sudo
	# invocations will succeed non-interactively.
	if (( EUID == 0)); then
		_ltz_print_error "This script cannot be run overall as root, try again as a non-root user"
		exit 1
	fi

	if (( ${#check_commands[@]} > 0 )); then
		IFS=$' '
		_ltz_print_progress "Fetching updates in these systems: ${package_managers[*]}"
		IFS=$'\n\t'
	fi

	if (( ${#require_sudo[@]} > 0 )); then
		IFS=$' '; _ltz_print_info "[!] Root privileges required for: ${require_sudo[*]}"; IFS=$'\n\t'
		_ltz_print_info "${BOLD}The script will now prompt you to authenticate using sudo."
		if sudo true; then
			_ltz_print_progress "Successfully elevated with sudo."
		else
			_ltz_print_error "Could not elevate privileges with sudo."
			return 1
		fi
	fi

	output="This information generated at: $(date)"
	output+=$'\n'
	output+=$(parallel ::: "${check_commands[@]}")

	if [[ -n "$UPDATE_LIST_OUTPUT_FILE" ]]; then
		echo "$output" > "$UPDATE_LIST_OUTPUT_FILE"
		_ltz_print_progress "Updatable packages output exported to: $UPDATE_LIST_OUTPUT_FILE"
	else
		echo "$output"
	fi
}

# arg 1: array name to populate with detected package manager names
# arg 2: array name to populate with check commands
# arg 3: array name to populate with commands which require root access
get_check_command_list() {
	declare -n detected_package_managers=$1
	declare -n output_commands=$2
	declare -n output_require_sudo=$3

	if type -t apt-get > /dev/null ; then
		detected_package_managers+=('apt')
		output_require_sudo+=('apt-get')
		output_commands+=('get_apt_updates')
	fi
	if type -t dnf > /dev/null ; then
		detected_package_managers+=('dnf')
		output_commands+=('get_dnf_updates')
	fi
	if type -t brew > /dev/null ; then
		detected_package_managers+=('brew')
		output_commands+=('get_brew_updates')
	fi
	if type -t flatpak > /dev/null ; then
		detected_package_managers+=('flatpak')
		output_commands+=('get_flatpak_updates')
	fi
	if type -t zypper > /dev/null ; then
		detected_package_managers+=('zypper')
		output_require_sudo+=('zypper')
		output_commands+=('get_zypper_updates')
		# output_commands+=('get_zypper_updates_test')
	fi
}

# NOTE: any functions which will be invoked within a parallel process must be exported with -f

get_apt_updates() {
	sudo apt-get update > /dev/null
	section_header "APT PACKAGES"
	apt list --upgradable
	echo ""
}
export -f get_apt_updates

get_dnf_updates() {
	dnf check-update --refresh > /dev/null
	section_header "APT PACKAGES"
	dnf list --updates
	echo ""
}
export -f get_dnf_updates

get_brew_updates() {
	# brew is VERY spammy to stderr
	section_header "HOMEBREW PACKAGES"
	brew outdated --verbose
	echo ""
	echo "Homebrew reminder:"
	echo "  To update homebrew itself, run \"brew update\""
	echo "  To update homebrew-managed packages, run \"brew upgrade\""
	echo ""
}
export -f get_brew_updates

get_flatpak_updates() {
	section_header "FLATPAK PACKAGES"
	{ flatpak remote-ls --updates --columns=name,version,download-size || return 1 ; } \
		| column --table --separator $'\t' --output-width 100
	echo ""
}
export -f get_flatpak_updates

get_zypper_updates() {
	section_header "ZYPPER PACKAGES"
	sudo zypper refresh > /dev/null

	local notable_awk_script all_entries_awk_script zypper_output
	notable_awk_script=$(cat << 'EOF'
BEGIN {
	notables["openSUSE-release"] = "openSUSE tumbleweed snapshot"
	notables["kernel-default"] = "kernel"
	notables["nvidia-common-G06"] = "nvidia driver"
}
/^v/ {
	gsub(/ /, "", $3)
	gsub(/ /, "", $4)
	gsub(/ /, "", $5)

	if ($3 in notables) {
		found_notables[notables[$3]] = sprintf("%s -> %s", $4, $5)
	}
}
END {
	print("NOTABLE UPDATES")
	for (name in found_notables) {
		printf("%s: %s\n", name, found_notables[name])
	}
}
EOF
	)

	local all_entries_awk_script
	all_entries_awk_script=$(cat << 'EOF'
/^v/ {
	gsub(/ /, "", $2)
	gsub(/ /, "", $3)
	gsub(/ /, "", $4)
	gsub(/ /, "", $5)
	# printf("%s %s->%s %s\n", $3, $4, $5, $2)
	print($3)
	printf("    %s  [%s]\n", $4, $2)
	printf(" -> %s\n", $5)
}

EOF
	)
	zypper_output=${ zypper list-updates; }
	awk -F '|' "$notable_awk_script" <<< "$zypper_output"
	echo ""
	awk -F '|' "$all_entries_awk_script" <<< "$zypper_output"
	echo ""
}
export -f get_zypper_updates

get_zypper_updates_test() {
	section_header "ZYPPER PACKAGES (MOCKED)"
	sudo echo "This is mocked output from zypper. Pretend it's really long."
	echo ""
}
export -f get_zypper_updates_test

# arg 1: name of section to be displayed
section_header() {
	local section_header=$1
	echo -e "\nÂ§ $section_header\n"
}
export -f section_header

main
